<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Presenter View - SlideChangerOnline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; background-color: #1f2937; }
        #presenter-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #pdf-canvas {
            display: block;
            width: 100%;
            height: auto;
            z-index: 1;
        }
        #annotation-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        #laser-point {
            position: absolute;
            width: 20px;
            height: 20px;
            background: red;
            border-radius: 50%;
            box-shadow: 0 0 10px red;
            z-index: 3;
            pointer-events: none;
            display: none;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">
    
    <div id="presenter-container">
        <canvas id="pdf-canvas"></canvas>
        <canvas id="annotation-canvas"></canvas>
        <div id="laser-point"></div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-message" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-900 text-white z-50">
        <svg class="animate-spin h-10 w-10 text-white mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <p class="text-xl">Loading presentation...</p>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore, doc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { getDatabase, ref, onValue, onChildAdded, remove, set } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCtlgsNhCEsKLHA-WmfoqQleW_n2kCQerI",
            authDomain: "slidechangeronline.firebaseapp.com",
            projectId: "slidechangeronline",
            storageBucket: "slidechangeronline.firebasestorage.app",
            messagingSenderId: "1013262596418",
            appId: "1:1013262596418:web:b7c9ee7e6da7545ff370db",
            databaseURL: "https://slidechangeronline-default-rtdb.asia-southeast1.firebasedatabase.app/"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const rtdb = getDatabase(app);

        let pdfDoc = null;
        let pageNum = 1;
        let isRendering = false;
        let scale = 1; 
        let totalPages = 0; // NEW: To track total pages for keyboard controls

        const container = document.getElementById('presenter-container');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const annCanvas = document.getElementById('annotation-canvas');
        const annCtx = annCanvas.getContext('2d');
        const laser = document.getElementById('laser-point');
        const loadingMsg = document.getElementById('loading-message');

        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js`;

        const params = new URLSearchParams(window.location.search);
        const presentationId = params.get('id');

        // Wake Lock
        let wakeLock = null;
        async function requestWakeLock() {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Screen Wake Lock active');
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
            }
        }

        // --- PDF Rendering ---
        function renderPage(num) {
            if (!pdfDoc || isRendering) return;
            isRendering = true;

            pdfDoc.getPage(num).then(function(page) {
                const viewport = page.getViewport({ scale: 1 });
                const availableWidth = window.innerWidth;
                const availableHeight = window.innerHeight;
                
                const scaleX = availableWidth / viewport.width;
                const scaleY = availableHeight / viewport.height;
                scale = Math.min(scaleX, scaleY) * 0.95; 
                
                const scaledViewport = page.getViewport({ scale: scale });

                pdfCanvas.width = scaledViewport.width;
                pdfCanvas.height = scaledViewport.height;
                annCanvas.width = scaledViewport.width;
                annCanvas.height = scaledViewport.height;
                
                container.style.width = `${scaledViewport.width}px`;
                container.style.height = `${scaledViewport.height}px`;

                const renderContext = {
                    canvasContext: pdfCtx,
                    viewport: scaledViewport
                };
                
                page.render(renderContext).promise.then(() => {
                    isRendering = false;
                    loadingMsg.classList.add('hidden');
                    // Once rendered, generate preview for remote
                    // (Optional: Implement preview gen if needed, removed for speed here)
                });
            });
            pageNum = num;
        }

        // --- RTDB Listeners (Annotations) ---
        function setupRealtimeListeners() {
            if (!presentationId) return;

            // Listen for Laser position
            onValue(ref(rtdb, `sessions/${presentationId}/laser`), (snapshot) => {
                const data = snapshot.val();
                if (data && data.active) {
                    laser.style.display = 'block';
                    laser.style.left = `${data.x * 100}%`;
                    laser.style.top = `${data.y * 100}%`;
                } else {
                    laser.style.display = 'none';
                }
            });

            // Listen for Drawings (Strokes)
            // We listen for new strokes added to the current page
            onChildAdded(ref(rtdb, `sessions/${presentationId}/drawings/${pageNum}`), (snapshot) => {
                const stroke = snapshot.val();
                drawStroke(stroke);
            });
            
            // Listen for Clear Signal
            onValue(ref(rtdb, `sessions/${presentationId}/clearSignal`), (snapshot) => {
                const signal = snapshot.val();
                if(signal && signal.timestamp > Date.now() - 2000) { // Only respect recent clears
                     annCtx.clearRect(0, 0, annCanvas.width, annCanvas.height);
                }
            });
        }

        function drawStroke(stroke) {
            if (!stroke.points || stroke.points.length < 2) return;
            
            annCtx.beginPath();
            annCtx.strokeStyle = stroke.color;
            annCtx.lineWidth = stroke.width;
            annCtx.lineCap = "round";
            annCtx.lineJoin = "round";

            const w = annCanvas.width;
            const h = annCanvas.height;

            const start = stroke.points[0];
            annCtx.moveTo(start.x * w, start.y * h);

            for (let i = 1; i < stroke.points.length; i++) {
                const p = stroke.points[i];
                annCtx.lineTo(p.x * w, p.y * h);
            }
            annCtx.stroke();
        }

        // NEW: Function to change the page via remote OR keyboard
        async function changePage(newPage) {
            if (newPage > 0 && newPage <= totalPages) {
                const docRef = doc(db, "presentations", presentationId);
                await updateDoc(docRef, { currentPage: newPage });
            }
        }

        // --- Init ---
        if (presentationId) {
            requestWakeLock();
            
            onSnapshot(doc(db, "presentations", presentationId), (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    totalPages = data.totalPages; // Store total pages

                    if (!pdfDoc && data.fileUrl) {
                        pdfjsLib.getDocument(data.fileUrl).promise.then((pDoc) => {
                            pdfDoc = pDoc;
                            renderPage(data.currentPage || 1);
                            setupRealtimeListeners();
                        });
                    } else if (pdfDoc && data.currentPage !== pageNum) {
                        // Clear annotations when page changes
                        annCtx.clearRect(0, 0, annCanvas.width, annCanvas.height);
                        renderPage(data.currentPage);
                        // NOTE: In a robust app, we'd detach old listeners and attach new ones for the new page.
                        // For simplicity in this step, we just clear the canvas.
                        // The `onChildAdded` listener above is bound to the *initial* pageNum.
                        // To fix this, we need to re-bind listeners on page change.
                        // Let's do that in the next refinement step once the basic rendering works.
                    }
                }
            });
        }

        window.addEventListener('resize', () => {
            if(pdfDoc) renderPage(pageNum);
        });
        
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                requestWakeLock();
            }
        });

         // NEW: Keyboard Controls Event Listener
        document.addEventListener('keydown', (event) => {
            if (!pdfDoc) return; // Don't do anything if PDF isn't loaded
            
            if (event.key === 'ArrowRight') {
                changePage(pageNum + 1);
            } else if (event.key === 'ArrowLeft') {
                changePage(pageNum - 1);
            }
        });

    </script>
</body>
</html>
