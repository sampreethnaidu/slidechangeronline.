<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Remote - SlideChangerOnline</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #000; overflow: hidden; margin: 0; padding: 0; width: 100vw; height: 100vh; }
        #remote-wrapper { display: flex; flex-direction: column; height: 100vh; }
        #slide-view { position: relative; flex-grow: 1; background: #111; display: flex; justify-content: center; align-items: center; overflow: hidden; }
        #pdf-canvas { display: block; max-width: 100%; max-height: 100%; }
        /* touch-action remains here for drawing surface only */
        #touch-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; touch-action: none; }
        #local-ink-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; }
        #toolbar { height: 170px; background: #1f2937; border-top: 1px solid #374151; padding: 12px; display: flex; flex-direction: column; gap: 10px; z-index: 20; }
        .tool-btn { padding: 10px; background: #374151; border-radius: 8px; color: #d1d5db; border: 2px solid transparent; font-weight: 600; text-align: center; font-size: 0.85rem; }
        .tool-btn.active { border-color: #f59e0b; background: #4b5563; color: white; }
        #loading-overlay { position: fixed; inset: 0; background: #111827; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; transition: opacity 0.5s ease; }
        #status-log { color: #9ca3af; font-size: 0.7rem; margin-top: 1rem; font-family: monospace; text-align: center; max-width: 80%; }
        .error-text { color: #f87171 !important; }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <div id="loader-icon" class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-amber-500 mb-4"></div>
        <p class="text-white font-medium">Remote Synchronizing</p>
        <div id="status-log">Initializing Firebase...</div>
        <button id="retry-btn" class="hidden mt-4 bg-gray-700 px-4 py-2 rounded text-sm text-white">Retry Connection</button>
    </div>

    <div id="remote-wrapper">
        <div id="slide-view">
            <canvas id="pdf-canvas"></canvas>
            <canvas id="local-ink-canvas"></canvas>
            <div id="touch-layer"></div>
        </div>

        <div id="toolbar">
            <div class="grid grid-cols-4 gap-2">
                <button class="tool-btn active" id="tool-pointer" data-mode="pointer">üëÜ Move</button>
                <button class="tool-btn" id="tool-laser" data-mode="laser">üî¥ Laser</button>
                <button class="tool-btn" id="tool-pen" data-mode="pen">‚úèÔ∏è Pen</button>
                <button class="tool-btn bg-red-900/50 text-red-200 border-red-800" id="tool-clear">üóëÔ∏è Clear</button>
            </div>

            <div class="grid grid-cols-3 gap-2 flex-grow">
                <button id="prev-btn" class="bg-blue-600 rounded-lg font-bold text-xl active:scale-95 transition-transform">PREV</button>
                <div class="flex flex-col items-center justify-center bg-gray-800 rounded-lg border border-gray-700">
                    <span id="page-indicator" class="text-[10px] font-mono text-gray-400">SESSION: ACTIVE</span>
                    <span id="page-number" class="text-lg font-bold">1 / 1</span>
                    <button id="refresh-btn" class="text-[10px] text-amber-500 hover:underline">FORCE RE-SYNC</button>
                </div>
                <button id="next-btn" class="bg-green-600 rounded-lg font-bold text-xl active:scale-95 transition-transform">NEXT</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore, doc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { getDatabase, ref, set, push, onChildAdded, off, remove } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCtlgsNhCEsKLHA-WmfoqQleW_n2kCQerI",
            authDomain: "slidechangeronline.firebaseapp.com",
            projectId: "slidechangeronline",
            storageBucket: "slidechangeronline.firebasestorage.app",
            messagingSenderId: "1013262596418",
            appId: "1:1013262596418:web:b7c9ee7e6da7545ff370db",
            databaseURL: "https://slidechangeronline-default-rtdb.asia-southeast1.firebasedatabase.app/"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const rtdb = getDatabase(app);

        const overlay = document.getElementById('loading-overlay');
        const statusLog = document.getElementById('status-log');
        const retryBtn = document.getElementById('retry-btn');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const inkCanvas = document.getElementById('local-ink-canvas');
        const inkCtx = inkCanvas.getContext('2d');
        const touchLayer = document.getElementById('touch-layer');
        const toolBtns = document.querySelectorAll('.tool-btn');
        const pageNumDisplay = document.getElementById('page-number');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');

        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js`;

        let pdfDoc = null;
        let currentPageNum = 1;
        let totalPages = 1;
        let isRendering = false;
        let currentMode = 'pointer';
        let isDrawing = false;
        let currentPath = [];
        let currentDrawingsRef = null;

        const params = new URLSearchParams(window.location.search);
        const presentationId = params.get('id');

        function updateStatus(msg, isError = false) {
            statusLog.textContent = msg;
            if (isError) {
                statusLog.classList.add('error-text');
                retryBtn.classList.remove('hidden');
                document.getElementById('loader-icon').classList.add('hidden');
            }
        }

        async function renderPage(num) {
            if (!pdfDoc || isRendering) return;
            isRendering = true;
            try {
                const page = await pdfDoc.getPage(num);
                const viewport = page.getViewport({ scale: 1 });
                const wrapper = document.getElementById('slide-view');
                const scale = Math.min(wrapper.clientWidth / viewport.width, wrapper.clientHeight / viewport.height);
                const scaledViewport = page.getViewport({ scale });

                pdfCanvas.width = scaledViewport.width;
                pdfCanvas.height = scaledViewport.height;
                inkCanvas.width = scaledViewport.width;
                inkCanvas.height = scaledViewport.height;
                touchLayer.style.width = `${scaledViewport.width}px`;
                touchLayer.style.height = `${scaledViewport.height}px`;

                await page.render({ canvasContext: pdfCtx, viewport: scaledViewport }).promise;
                currentPageNum = num;
                clearInk();
                attachInkListener(num);
            } catch (e) {
                updateStatus("Render Failed: " + e.message, true);
            } finally {
                isRendering = false;
            }
        }

        function clearInk() { inkCtx.clearRect(0, 0, inkCanvas.width, inkCanvas.height); }

        function drawStroke(stroke) {
            if (!stroke || !stroke.points || stroke.points.length < 2) return;
            inkCtx.beginPath();
            inkCtx.strokeStyle = stroke.color || "red";
            inkCtx.lineWidth = stroke.width || 4;
            inkCtx.lineCap = "round";
            inkCtx.lineJoin = "round";
            const w = inkCanvas.width;
            const h = inkCanvas.height;
            inkCtx.moveTo(stroke.points[0].x * w, stroke.points[0].y * h);
            stroke.points.forEach(p => inkCtx.lineTo(p.x * w, p.y * h));
            inkCtx.stroke();
        }

        function attachInkListener(num) {
            if (currentDrawingsRef) off(currentDrawingsRef);
            currentDrawingsRef = ref(rtdb, `sessions/${presentationId}/drawings/${num}`);
            onChildAdded(currentDrawingsRef, (snap) => drawStroke(snap.val()));
        }

        function getNormalizedCoords(e) {
            const rect = touchLayer.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: (clientX - rect.left) / rect.width, y: (clientY - rect.top) / rect.height };
        }

        const handleStart = (e) => {
            // If in pointer mode, do NOT prevent default so buttons/scrolling work
            if (currentMode === 'pointer') return;
            
            // Prevent scrolling/tapping on the slide when using Laser or Pen
            e.preventDefault();
            isDrawing = true;
            const coords = getNormalizedCoords(e);
            if (currentMode === 'laser') updateLaser(coords, true);
            else if (currentMode === 'pen') currentPath = [coords];
        };

        const handleMove = (e) => {
            if (!isDrawing) return;
            const coords = getNormalizedCoords(e);
            if (currentMode === 'laser') updateLaser(coords, true);
            else if (currentMode === 'pen') {
                const lastPoint = currentPath[currentPath.length - 1];
                drawStroke({ points: [lastPoint, coords], color: "red", width: 4 });
                currentPath.push(coords);
            }
        };

        const handleEnd = () => {
            if (!isDrawing) return;
            isDrawing = false;
            if (currentMode === 'laser') updateLaser({ x: 0, y: 0 }, false);
            else if (currentMode === 'pen' && currentPath.length > 1) {
                push(ref(rtdb, `sessions/${presentationId}/drawings/${currentPageNum}`), {
                    points: currentPath, color: "red", width: 4, timestamp: Date.now()
                });
            }
            currentPath = [];
        };

        function updateLaser(coords, active) {
            set(ref(rtdb, `sessions/${presentationId}/laser`), { x: coords.x, y: coords.y, active: active, timestamp: Date.now() });
        }

        if (presentationId) {
            updateStatus("Fetching Session Data...");
            const docRef = doc(db, "presentations", presentationId);
            
            onSnapshot(docRef, (snap) => {
                if (snap.exists()) {
                    const data = snap.data();
                    updateStatus("Loading PDF Content...");
                    if (!pdfDoc && data.fileUrl) {
                        pdfjsLib.getDocument(data.fileUrl).promise.then(doc => {
                            pdfDoc = doc;
                            totalPages = doc.numPages;
                            renderPage(data.currentPage || 1);
                            
                            // Hiding overlay with pointer-events fix
                            overlay.style.opacity = '0';
                            overlay.style.pointerEvents = 'none'; 
                            setTimeout(() => overlay.classList.add('hidden'), 500);
                        }).catch(err => {
                            updateStatus("PDF Access Denied (CORS or 404)", true);
                        });
                    } else if (pdfDoc && data.currentPage !== currentPageNum) {
                        renderPage(data.currentPage);
                    }
                    pageNumDisplay.textContent = `${data.currentPage || 1} / ${totalPages}`;
                } else {
                    updateStatus("Session Expired or Deleted", true);
                }
            }, (err) => {
                updateStatus("Firestore Connection Failed: " + err.code, true);
            });

            toolBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    toolBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentMode = btn.dataset.mode;
                });
            });

            document.getElementById('tool-clear').addEventListener('click', () => {
                remove(ref(rtdb, `sessions/${presentationId}/drawings/${currentPageNum}`));
                set(ref(rtdb, `sessions/${presentationId}/clearSignal`), { timestamp: Date.now() });
                clearInk();
            });

            document.getElementById('refresh-btn').addEventListener('click', () => location.reload());
            retryBtn.addEventListener('click', () => location.reload());

            prevBtn.addEventListener('click', () => { if (currentPageNum > 1) updateDoc(docRef, { currentPage: currentPageNum - 1 }); });
            nextBtn.addEventListener('click', () => { if (currentPageNum < totalPages) updateDoc(docRef, { currentPage: currentPageNum + 1 }); });

            touchLayer.addEventListener('touchstart', handleStart, { passive: false });
            touchLayer.addEventListener('touchmove', handleMove, { passive: false });
            touchLayer.addEventListener('touchend', handleEnd);
            touchLayer.addEventListener('mousedown', handleStart);
            touchLayer.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd);
        } else {
            updateStatus("Error: No Session ID Provided", true);
        }
    </script>
</body>
</html>
